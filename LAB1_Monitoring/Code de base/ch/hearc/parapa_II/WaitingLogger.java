package ch.hearc.parapa_II;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.FutureTask;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.locks.ReentrantLock;
import java.util.stream.Collectors;

public class WaitingLogger {
	// Singleton lock
	private final static ReentrantLock lockSingleton = new ReentrantLock();
	private static WaitingLogger instance;

	/*
	 * -----------------------------------------------------------------------------
	 * ------------------
	 * TODO : Prevoir un stockage concurrent pour les logs et pour les listes
	 * d'attente des documents
	 * 
	 * Remarque : java.util.concurrent contient tout ce qu'il faut
	 * -----------------------------------------------------------------------------
	 * ------------------
	 */

	// Log storage
	private BlockingQueue<Log> logs;

	private BlockingQueue<Person> waitingLists;
	private BlockingQueue<Person> processingLists;
	private BlockingQueue<Person> finishedLists;

	// Variables
	private ArrayList<Person> persons;

	// Singletons
	private Database db;

	private FutureTask<String> consoleFuture;

	/**
	 * Constructor
	 */
	private WaitingLogger() {
		db = Database.getInstance();

		// Initialiser les structures de donnees
		logs = new LinkedBlockingQueue<>();
		waitingLists = new LinkedBlockingQueue<>();
		processingLists = new LinkedBlockingQueue<>();
		finishedLists = new LinkedBlockingQueue<>();
	}

	/**
	 * Singleton instance
	 * 
	 * @return the instance of the waiting logger
	 */
	public static WaitingLogger getInstance() {
		lockSingleton.lock();
		if (instance == null) {
			instance = new WaitingLogger();
		}
		lockSingleton.unlock();

		return instance;
	}

	/**
	 * Assign the future task to be able to cancel it when all threads are done
	 * 
	 * @param consoleFuture Future task running the main thread
	 * @param persons       List of persons generated by the main thread
	 */
	public void assignConsoleFuture(FutureTask<String> consoleFuture, ArrayList<Person> persons) {
		this.consoleFuture = consoleFuture;
		this.persons = persons;
	}

	/**
	 * Add a thread to the waiting queue
	 * 
	 * @param p     Person waiting to access a document
	 * @param timer Time of the operation
	 */
	public void addWaiting(Person p, long timer) {
		this.sleep(timer);

		// Log the operation
		logs.add(new Log(Log.Type.WAITING, p));
	}

	/**
	 * Remove a thread from the waiting queue and add it to the processing queue
	 * 
	 * @param p     Person accessing the document
	 * @param timer Time of the operation
	 */
	public void removeWaiting(Person p, long timer) {
		this.sleep(timer);

		// Log the operation
		logs.add(new Log(Log.Type.REMOVE, p));
	}

	/**
	 * Remove a thread from the processing queue
	 * 
	 * @param p     Person finishing to access the document
	 * @param timer Time of the operation
	 */
	public void finished(Person p, long timer) {
		// /*
		// * --------------------------------------------
		// * TODO : Indiquer la fin d'acces a un document
		// *
		// * Remarque : ne pas oublier la concurrence
		// * --------------------------------------------
		// */

		this.sleep(timer);

		// Log the operation
		logs.add(new Log(Log.Type.FINISHED, p));
	}

	/**
	 * Called by the user on typing 'NEXT', display the next operation logged
	 */
	public void popNextLog() {
		Log nextLog = null;

		/*
		 * -----------------------------------------------------------------------------
		 * TODO : Recuperer le prochain log du stockage pour le traitement
		 * 
		 * Remarque : a vous de definir votre type de stockage selon l'UI et
		 * l'infrastructure que vous voulez utiliser
		 * -----------------------------------------------------------------------------
		 */

		nextLog = logs.poll();

		Person p = nextLog.getPerson();
		Document d = p.getDocument();

		// Treat log type
		switch (nextLog.getType()) {
			case WAITING:
				/*
				 * -----------------------------------------------------------------------------
				 * TODO : Gestion d'un log indiquant l'attente d'un thread sur sa ressource
				 * partagee
				 * 
				 * Remarque : cette etape consiste a gerer vos lites d'attentes
				 * -----------------------------------------------------------------------------
				 */
				try {
					waitingLists.put(p);
				} catch (InterruptedException e) {
					Thread.currentThread().interrupt();
					return;
				}

				break;
			case REMOVE:
				/*
				 * -----------------------------------------------------------------------------
				 * TODO : Gestion d'un log indiquant l'acces d'un thread a sa ressource partagee
				 * 
				 * Remarque : cette etape consiste a gerer vos lites d'attentes
				 * -----------------------------------------------------------------------------
				 */
				try {
					// Remove the person from the waiting list
					waitingLists.remove(p);

					processingLists.put(p);
				} catch (InterruptedException e) {
					Thread.currentThread().interrupt();
					return;
				}

				break;
			case FINISHED:
				/*
				 * -----------------------------------------------------------------------------
				 * TODO : Gestion d'un log indiquant la fin d'un thread et la liberation de
				 * l'acces a sa ressource
				 * 
				 * Remarque : cette etape consiste a gerer vos lites d'attentes
				 * -----------------------------------------------------------------------------
				 */
				try {
					processingLists.remove(p);

					finishedLists.put(p);
				} catch (InterruptedException e) {
					Thread.currentThread().interrupt();
					return;
				}

				break;
			default:
				break;
		}

		/*
		 * ---------------------------------------------------
		 * TODO : Affichage du prochain log sur l'UI / console
		 * 
		 * Remarque : -
		 * ---------------------------------------------------
		 */

		// Get all the waiting persons for the document
		ArrayList<Person> waitingPersons = waitingLists//
				.stream()//
				.filter(person -> person.getDocument().equals(d))
				.collect(Collectors.toCollection(ArrayList::new));

		// Get all the processing persons for the document
		ArrayList<Person> processingPersons = processingLists//
				.stream()//
				.filter(person -> person.getDocument().equals(d))
				.collect(Collectors.toCollection(ArrayList::new));

		
		// Get all the finished persons for the document
		ArrayList<Person> finishedPersons = finishedLists//
				.stream()//
				.filter(person -> person.getDocument().equals(d))
				.collect(Collectors.toCollection(ArrayList::new));

		// Display the next log
		System.out.println("Document : " + d.getName());
		System.out.println("Waiting : " + waitingPersons);
		System.out.println("Processing : " + processingPersons);
		System.out.println("Finished : " + finishedPersons);
		
		System.out.println(nextLog.toString());

		/*
		 * -----------------------------------------------------------------------------
		 * ------------------------------------------------------
		 * TODO : Controller si il s'agit du dernier log, arreter le programme si c'est
		 * le cas
		 * 
		 * Remarque : interrompre consoleFuture
		 * (2 conditions doivent etre reunies : logs == 0 et nombre de threads termines
		 * correspondant aux nombre total de personnes)
		 * -----------------------------------------------------------------------------
		 * ------------------------------------------------------
		 */
		if (logs.size() == 0 && finishedLists.size() == persons.size()) {
			// TODO : Interrompre consoleFuture
			consoleFuture.cancel(true);
		}

	}

	private void sleep(long ms) {
		try {
			Thread.sleep(ms);
		} catch (InterruptedException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}
}
