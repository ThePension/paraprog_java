package ch.hearc.parapa_II;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.FutureTask;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.locks.ReentrantLock;
import java.util.function.Consumer;
import java.util.stream.Collectors;

public class WaitingLogger {
	// Singleton lock
	private final static ReentrantLock lockSingleton = new ReentrantLock();
	private static WaitingLogger instance;
	private static final String DIAGRAM_SEPARATOR = "----------";

	/*
	 * -----------------------------------------------------------------------------
	 * ------------------
	 * TODO : Prevoir un stockage concurrent pour les logs et pour les listes
	 * d'attente des documents
	 * 
	 * Remarque : java.util.concurrent contient tout ce qu'il faut
	 * -----------------------------------------------------------------------------
	 * ------------------
	 */

	// Log storage
	private BlockingQueue<Log> logs;

	private BlockingQueue<Person> waitingLists;
	private BlockingQueue<Person> processingLists;
	private BlockingQueue<Person> finishedLists;

	// Variables
	private ArrayList<Person> persons;
	private Set<Document> documents;

	// Singletons
	private Database db;

	private FutureTask<String> consoleFuture;

	// Diagrams tools : contain the last time a person finished to access a document
	private int diagramIndex = 0;

	/**
	 * Constructor
	 */
	private WaitingLogger() {
		db = Database.getInstance();

		// Initialiser les structures de donnees
		logs = new LinkedBlockingQueue<>();
		waitingLists = new LinkedBlockingQueue<>();
		processingLists = new LinkedBlockingQueue<>();
		finishedLists = new LinkedBlockingQueue<>();

		documents = db.getDocuments();
	}

	/**
	 * Singleton instance
	 * 
	 * @return the instance of the waiting logger
	 */
	public static WaitingLogger getInstance() {
		lockSingleton.lock();
		if (instance == null) {
			instance = new WaitingLogger();
		}
		lockSingleton.unlock();

		return instance;
	}

	/**
	 * Assign the future task to be able to cancel it when all threads are done
	 * 
	 * @param consoleFuture Future task running the main thread
	 * @param persons       List of persons generated by the main thread
	 */
	public void assignConsoleFuture(FutureTask<String> consoleFuture, ArrayList<Person> persons) {
		this.consoleFuture = consoleFuture;
		this.persons = persons;
	}

	/**
	 * Add a thread to the waiting queue
	 * 
	 * @param p     Person waiting to access a document
	 * @param timer Time of the operation
	 */
	public void addWaiting(Person p, long timer) {
		this.sleep(timer);

		// Log the operation
		logs.add(new Log(Log.Type.WAITING, p, p.timePassed()));
	}

	/**
	 * Remove a thread from the waiting queue and add it to the processing queue
	 * 
	 * @param p     Person accessing the document
	 * @param timer Time of the operation
	 */
	public void removeWaiting(Person p, long timer) {
		this.sleep(timer);

		// Log the operation
		logs.add(new Log(Log.Type.REMOVE, p, p.timePassed()));
	}

	/**
	 * Remove a thread from the processing queue
	 * 
	 * @param p     Person finishing to access the document
	 * @param timer Time of the operation
	 */
	public void finished(Person p, long timer) {
		// /*
		// * --------------------------------------------
		// * TODO : Indiquer la fin d'acces a un document
		// *
		// * Remarque : ne pas oublier la concurrence
		// * --------------------------------------------
		// */

		this.sleep(timer);

		// Log the operation
		logs.add(new Log(Log.Type.FINISHED, p, p.timePassed()));
	}

	/**
	 * Called by the user on typing 'NEXT', display the next operation logged
	 */
	public boolean popNextLog() {
		if (logs.size() == 0)
			return false;

		Log nextLog = logs.poll();

		Person p = nextLog.getPerson();

		// Treat log type
		switch (nextLog.getType()) {
			case WAITING:
				try {
					waitingLists.put(p);

					// Calculate the space gap based on the starting time
					int spaceGap = (int) (p.getStartingTime()) / 1000;

					// Update the diagram with " " * spaceGap + "W"
					p.updateDiagram(" ".repeat(spaceGap * 5) + "W");

				} catch (InterruptedException e) {
					Thread.currentThread().interrupt();
					return false;
				}

				break;
			case REMOVE:
				try {
					// Remove the person from the waiting list
					waitingLists.remove(p);

					processingLists.put(p);

					// If the person has been waiting to access the document
					if (nextLog.getElapsedTime() > 0) {
						// Calculate the space gap based on the starting time
						int spaceGap = (int) (nextLog.getElapsedTime()) / 1000;

						// Update the diagram with " " * spaceGap + "W"
						p.updateDiagram("-".repeat(spaceGap * 5) + "T");
					} else {
						// Else, if the person is the first to access the document
						// Calculate the space gap based on the starting time
						int spaceGap = (int) (p.getStartingTime()) / 1000;

						// Update the diagram with " " * spaceGap + "W"
						p.updateDiagram(" ".repeat(spaceGap * 5) + "W");
					}
				} catch (InterruptedException e) {
					Thread.currentThread().interrupt();
					return false;
				}

				break;
			case FINISHED:
				try {
					processingLists.remove(p);

					finishedLists.put(p);

					// Calculate the space gap based on the starting time
					int spaceGap = (int) (p.getDurationTime()) / 1000;

					// Update the diagram with "-" * spaceGap + "W"
					p.updateDiagram("-".repeat(spaceGap * 5) + "F");
				} catch (InterruptedException e) {
					Thread.currentThread().interrupt();
					return false;
				}

				break;
			default:
				break;
		}

		/*
		 * ---------------------------------------------------
		 * TODO : Affichage du prochain log sur l'UI / console
		 * 
		 * Remarque : -
		 * ---------------------------------------------------
		 */

		System.out.println("-- Threads list -------------------------------------\n");

		// Display all the threads (persons)
		persons.stream().forEach(Person::display);

		System.out.println("\n-- Queues state -------------------------------------\n");

		Consumer<Document> displayDocumentQueueStateConsumer = createDisplayDocumentQueueStateConsumer();

		// Foreach document, display the waiting and processing persons
		documents.forEach(displayDocumentQueueStateConsumer);

		System.out.println("\n-- Diagram ---------------------------------------------\n");

		System.out.println("W : Waiting / R : Remove from waiting / T : W + R / F : Finished\n");

		persons.stream().map(Person::getDiagramLog).forEach(System.out::println);

		/*
		 * -----------------------------------------------------------------------------
		 * TODO : Controller si il s'agit du dernier log, arreter le programme si c'est
		 * le cas
		 * 
		 * Remarque : interrompre consoleFuture
		 * (2 conditions doivent etre reunies : logs == 0 et nombre de threads termines
		 * correspondant aux nombre total de personnes)
		 * -----------------------------------------------------------------------------
		 */
		if (logs.size() == 0 && finishedLists.size() == persons.size()) {
			consoleFuture.cancel(true);
		}

		return true;
	}

	private void sleep(long ms) {
		try {
			Thread.sleep(ms);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
	}

	private Consumer<Document> createDisplayDocumentQueueStateConsumer() {
		return document -> {
			// Get all the waiting persons for the document
			ArrayList<Person> waitingPersons2 = waitingLists//
					.stream()//
					.parallel()
					.filter(person -> person.getDocument().equals(document))
					.collect(Collectors.toCollection(ArrayList::new));

			// Get all the processing persons for the document
			ArrayList<Person> processingPersons2 = processingLists//
					.stream()//
					.parallel()
					.filter(person -> person.getDocument().equals(document))
					.collect(Collectors.toCollection(ArrayList::new));

			// Get all the finished persons for the document
			ArrayList<Person> finishedPersons2 = finishedLists//
					.stream()//
					.parallel()
					.filter(person -> person.getDocument().equals(document))
					.collect(Collectors.toCollection(ArrayList::new));

			System.out.println("\n" + document.getName() + " (WAITING): "
					+ waitingPersons2.stream().map(Person::getNameAndRole).collect(Collectors.joining(", ")));
			System.out.println(document.getName() + " (PROCESSING): "
					+ processingPersons2.stream().map(Person::getNameAndRole).collect(Collectors.joining(", ")));
			System.out.println(document.getName() + " (FINISHED): "
					+ finishedPersons2.stream().map(Person::getNameAndRole).collect(Collectors.joining(", ")));
		};
	}

	// private Consumer<Person> createDisplayPersonDiagramConsumer() {
	// return person -> {
	// System.out.print("\n" + person.getNameAndRole() + " : ");

	// // Check if the person is the last entering the waiting list (blockingqueue)
	// if (waitingLists.peek() != null && waitingLists.peek().equals(person)) {
	// person.updateDiagram("W");
	// }

	// // Check if the person is processing the document
	// if (processingLists.contains(person)) {
	// person.updateDiagram("W");
	// }

	// // Check if the person has finished processing the document
	// if (finishedLists.contains(person)) {
	// person.updateDiagram(DIAGRAM_SEPARATOR + "T");
	// }

	// System.out.println(person.getDiagramLog());
	// };
	// }
}
