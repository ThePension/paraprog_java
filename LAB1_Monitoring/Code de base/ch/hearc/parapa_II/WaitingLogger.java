package ch.hearc.parapa_II;

import java.util.ArrayList;
import java.util.concurrent.FutureTask;
import java.util.concurrent.locks.ReentrantLock;

public class WaitingLogger 
{
	// Singleton lock
	private final static ReentrantLock lockSingleton = new ReentrantLock();
	private static WaitingLogger instance;
	
	/*
	 * -----------------------------------------------------------------------------------------------
	 * TODO : Prevoir un stockage concurrent pour les logs et pour les listes d'attente des documents
	 * 
	 * Remarque : java.util.concurrent contient tout ce qu'il faut
	 * -----------------------------------------------------------------------------------------------
	 */
	
	// Variables
	private ArrayList<Person> persons;
	
	// Singletons
	private Database db;
	
	private FutureTask<String> consoleFuture;
	
	/**
	 * Constructor
	 */
	private WaitingLogger()
	{
		db = Database.getInstance();
	}
	
	/**
	 * Singleton instance
	 * @return the instance of the waiting logger
	 */
	public static WaitingLogger getInstance()
	{
		lockSingleton.lock();
		if (instance == null)
		{
			instance = new WaitingLogger();
		}
		lockSingleton.unlock();
		
		return instance;
	}
	
	/**
	 * Assign the future task to be able to cancel it when all threads are done
	 * @param consoleFuture Future task running the main thread
	 * @param persons List of persons generated by the main thread
	 */
	public void assignConsoleFuture(FutureTask<String> consoleFuture, ArrayList<Person> persons)
	{
		this.consoleFuture = consoleFuture;
		this.persons = persons;
	}
	
	/**
	 * Add a thread to the waiting queue
	 * @param p Person waiting to access a document
	 * @param timer Time of the operation
	 */
	public void addWaiting(Person p, long timer)
	{
		/*
		 * -----------------------------------------------------------------------------------
		 * TODO : Ajouter une personne (thread) dans la liste d'attente d'acces a son document
		 * 
		 * Remarque : ne pas oublier la concurrence
		 * -----------------------------------------------------------------------------------
		 */
	}
	
	/**
	 * Remove a thread from the waiting queue and add it to the processing queue
	 * @param p Person accessing the document
	 * @param timer Time of the operation
	 */
	public void removeWaiting(Person p, long timer)
	{
		/*
		 * ---------------------------------------------------------------------------------
		 * TODO : Enlever une personne (thread) de la liste d'attente d'acces a son document
		 * 
		 * Remarque : ne pas oublier la concurrence
		 * ---------------------------------------------------------------------------------
		 */
	}
	
	/**
	 * Remove a thread from the processing queue
	 * @param p Person finishing to access the document
	 * @param timer Time of the operation
	 */
	public void finished(Person p, long timer)
	{
		/*
		 * --------------------------------------------
		 * TODO : Indiquer la fin d'acces a un document
		 * 
		 * Remarque : ne pas oublier la concurrence
		 * --------------------------------------------
		 */
	}
	
	/**
	 * Called by the user on typing 'NEXT', display the next operation logged
	 */
	public void popNextLog()
	{
		Log nextLog = null;
		
		/*
		 * -----------------------------------------------------------------------------------------------------------
		 * TODO : Recuperer le prochain log du stockage pour le traitement
		 * 
		 * Remarque : a vous de definir votre type de stockage selon l'UI et l'infrastructure que vous voulez utiliser
		 * -----------------------------------------------------------------------------------------------------------
		 */
		
		// Treat log type
		switch (nextLog.getType())
		{
			case WAITING:
				/*
				 * ---------------------------------------------------------------------------------
				 * TODO : Gestion d'un log indiquant l'attente d'un thread sur sa ressource partagee
				 * 
				 * Remarque : cette etape consiste a gerer vos lites d'attentes
				 * ---------------------------------------------------------------------------------
				 */
				break;
			case REMOVE:
				/*
				 * -----------------------------------------------------------------------------
				 * TODO : Gestion d'un log indiquant l'acces d'un thread a sa ressource partagee
				 * 
				 * Remarque : cette etape consiste a gerer vos lites d'attentes
				 * -----------------------------------------------------------------------------
				 */
				break;
			case FINISHED:
				/*
				 * -----------------------------------------------------------------------------------------------
				 * TODO : Gestion d'un log indiquant la fin d'un thread et la liberation de l'acces a sa ressource
				 * 
				 * Remarque : cette etape consiste a gerer vos lites d'attentes
				 * -----------------------------------------------------------------------------------------------
				 */
				break;
			default:
				break;
		}
		
		/*
		 * ---------------------------------------------------
		 * TODO : Affichage du prochain log sur l'UI / console
		 * 
		 * Remarque : -
		 * ---------------------------------------------------
		 */

		/*
		 * -----------------------------------------------------------------------------------------------------------------------------------
		 * TODO : Controller si il s'agit du dernier log, arreter le programme si c'est le cas
		 * 
		 * Remarque : interrompre consoleFuture 
		 *            (2 conditions doivent etre reunies : logs == 0 et nombre de threads termines correspondant aux nombre total de personnes)
		 * -----------------------------------------------------------------------------------------------------------------------------------
		 */
	}
}
